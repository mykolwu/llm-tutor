[
  {
    "type": "h2",
    "content": "2.4   Mutable Data"
  },
  {
    "type": "p",
    "content": "We have seen how abstraction is vital in helping us to cope with the complexity\nof large systems.  Effective programming also requires organizational\nprinciples that can guide us in formulating the overall design of a program. In\nparticular, we need strategies to help us structure large systems to be\nmodular, meaning that they divide naturally into coherent parts that can be\nseparately developed and maintained."
  },
  {
    "type": "p",
    "content": "One powerful technique for creating modular programs is to incorporate data\nthat may change state over time.  In this way, a single data object can\nrepresent something that evolves independently of the rest of the program. The\nbehavior of a changing object may be influenced by its history, just like an\nentity in the world. Adding state to data is a central ingredient of a paradigm\ncalled object-oriented programming."
  },
  {
    "type": "h3",
    "content": "2.4.1   The Object Metaphor"
  },
  {
    "type": "p",
    "content": "In the beginning of this text, we distinguished between functions and data:\nfunctions performed operations and data were operated upon.  When we included\nfunction values among our data, we acknowledged that data too can have\nbehavior. Functions could be manipulated as data, but could also be called to\nperform computation."
  },
  {
    "type": "p",
    "content": "Objectscombine data values with behavior.  Objects represent information,\nbut alsobehavelike the things that they represent.  The logic of how an\nobject interacts with other objects is bundled along with the\ninformation that encodes the object's value.  When an object is printed, it\nknows how to spell itself out in text.  If an object is composed of parts, it\nknows how to reveal those parts on demand.  Objects are both information and\nprocesses, bundled together to represent the properties, interactions, and\nbehaviors of complex things."
  },
  {
    "type": "p",
    "content": "Object behavior is implemented in Python through specialized object syntax\nand associated terminology, which we can introduce by example.  A date is a\nkind of object."
  },
  {
    "type": "code",
    "content": ">>> from datetime import date\n"
  },
  {
    "type": "p",
    "content": "The namedateis bound to aclass. As we have seen, a class represents a\nkind of value. Individual dates are calledinstancesof that class.\nInstances can beconstructedby calling the class on arguments that\ncharacterize the instance."
  },
  {
    "type": "code",
    "content": ">>> tues = date(2014, 5, 13)\n"
  },
  {
    "type": "p",
    "content": "Whiletueswas constructed from primitive numbers, it behaves like a date.\nFor instance, subtracting it from another date will give a time difference,\nwhich we can print."
  },
  {
    "type": "code",
    "content": ">>> print(date(2014, 5, 19) - tues)\n6 days, 0:00:00\n"
  },
  {
    "type": "p",
    "content": "Objects haveattributes, which are named values that are part of the object.\nIn Python, like many other programming languages, we use dot notation to\ndesignated an attribute of an object."
  },
  {
    "type": "p",
    "content": "Above, the<expression>evaluates to an object, and<name>is the name\nof an attribute for that object."
  },
  {
    "type": "p",
    "content": "Unlike the names that we have considered so far, these attribute names are not\navailable in the general environment.  Instead, attribute names are particular\nto the object instance preceding the dot."
  },
  {
    "type": "code",
    "content": ">>> tues.year\n2014\n"
  },
  {
    "type": "p",
    "content": "Objects also havemethods, which are function-valued attributes.\nMetaphorically, we say that the object \"knows\" how to carry out those methods.\nBy implementation, methods are functions that compute their results from both\ntheir arguments and their object.  For example, Thestrftimemethod\n(a classic function name meant to evoke \"string format of time\") oftuestakes a single argument that specifies how to display a date (e.g.,%Ameans that the day of the week should be spelled out in full)."
  },
  {
    "type": "code",
    "content": ">>> tues.strftime('%A, %B %d')\n'Tuesday, May 13'\n"
  },
  {
    "type": "p",
    "content": "Computing the return value  ofstrftimerequires two inputs: the string\nthat describes the format of the output and the date information bundled intotues.  Date-specific logic is applied within this method to yield this\nresult.  We never stated that the 13th of May, 2014, was a Tuesday, but\nknowing the corresponding weekday is part of what it means to be a date.  By\nbundling behavior and information together, this Python object offers us a\nconvincing, self-contained abstraction of a date."
  },
  {
    "type": "p",
    "content": "Dates are objects, but numbers, strings, lists, and ranges are all objects as\nwell. They represent values, but also behave in a manner that befits the values\nthey represent. They also have attributes and methods. For instance, strings\nhave an array of methods that facilitate text processing."
  },
  {
    "type": "code",
    "content": ">>> '1234'.isnumeric()\nTrue\n>>> 'rOBERT dE nIRO'.swapcase()\n'Robert De Niro'\n>>> 'eyes'.upper().endswith('YES')\nTrue\n"
  },
  {
    "type": "p",
    "content": "In fact, all values in Python are objects. That is, all values have behavior\nand attributes. They act like the values they represent."
  },
  {
    "type": "h3",
    "content": "2.4.2   Sequence Objects"
  },
  {
    "type": "p",
    "content": "Instances of primitive built-in values such as numbers areimmutable. The\nvalues themselves cannot change over the course of program execution. Lists on\nthe other hand aremutable."
  },
  {
    "type": "p",
    "content": "Mutable objects are used to represent values that change over time. A person is\nthe same person from one day to the next, despite having aged, received a\nhaircut, or otherwise changed in some way. Similarly, an object may have\nchanging properties due tomutatingoperations. For example,  it is possible\nto change the contents of a list. Most changes are performed by invoking\nmethods on list objects."
  },
  {
    "type": "p",
    "content": "We can introduce many list modification operations through an example that\nillustrates the history of playing cards (drastically simplified). Comments in\nthe examples describe the effect of each method invocation."
  },
  {
    "type": "p",
    "content": "Playing cards were invented in China, perhaps around the 9th century. An early\ndeck had three suits, which corresponded to denominations of money."
  },
  {
    "type": "code",
    "content": ">>> chinese = ['coin', 'string', 'myriad']  # A list literal\n>>> suits = chinese                         # Two names refer to the same list\n"
  },
  {
    "type": "p",
    "content": "As cards migrated to Europe (perhaps through Egypt), only the suit of coins\nremained in Spanish decks (oro)."
  },
  {
    "type": "code",
    "content": ">>> suits.pop()             # Remove and return the final element\n'myriad'\n>>> suits.remove('string')  # Remove the first element that equals the argument\n"
  },
  {
    "type": "p",
    "content": "Three more suits were added (they evolved in name and design over time),"
  },
  {
    "type": "code",
    "content": ">>> suits.append('cup')              # Add an element to the end\n>>> suits.extend(['sword', 'club'])  # Add all elements of a sequence to the end\n"
  },
  {
    "type": "p",
    "content": "and Italians called swordsspades."
  },
  {
    "type": "code",
    "content": ">>> suits[2] = 'spade'  # Replace an element\n"
  },
  {
    "type": "p",
    "content": "giving the suits of a traditional Italian deck of cards."
  },
  {
    "type": "code",
    "content": ">>> suits\n['coin', 'cup', 'spade', 'club']\n"
  },
  {
    "type": "p",
    "content": "The French variant used today in the U.S. changes the first two suits:"
  },
  {
    "type": "code",
    "content": ">>> suits[0:2] = ['heart', 'diamond']  # Replace a slice\n>>> suits\n['heart', 'diamond', 'spade', 'club']\n"
  },
  {
    "type": "p",
    "content": "Methods also exist for inserting, sorting, and reversing lists.  All of these\nmutation operations change the value of the list; they do not create new list\nobjects."
  },
  {
    "type": "p",
    "content": "Sharing and Identity.Because we have been changing a single list rather\nthan creating new lists, the object bound to the namechinesehas also\nchanged, because it is the same list object that was bound tosuits!"
  },
  {
    "type": "code",
    "content": ">>> chinese  # This name co-refers with \"suits\" to the same changing list\n['heart', 'diamond', 'spade', 'club']\n"
  },
  {
    "type": "p",
    "content": "This behavior is new.  Previously, if a name did not appear in a statement,\nthen its value would not be affected by that statement.  With mutable data,\nmethods called on one name can affect another name at the same time."
  },
  {
    "type": "p",
    "content": "The environment diagram for this example shows how the value bound tochineseis changed by statements involving onlysuits. Step through\neach line of the following example to observe these changes."
  },
  {
    "type": "p",
    "content": "Lists can be copied using thelistconstructor function.  Changes to one\nlist do not affect another, unless they share structure."
  },
  {
    "type": "code",
    "content": ">>> nest = list(suits)  # Bind \"nest\" to a second list with the same elements\n>>> nest[0] = suits     # Create a nested list\n"
  },
  {
    "type": "p",
    "content": "According to this environment, changing the list referenced bysuitswill\naffect the nested list that is the first element ofnest, but not the other\nelements."
  },
  {
    "type": "code",
    "content": ">>> suits.insert(2, 'Joker')  # Insert an element at index 2, shifting the rest\n>>> nest\n[['heart', 'diamond', 'Joker', 'spade', 'club'], 'diamond', 'spade', 'club']\n"
  },
  {
    "type": "p",
    "content": "And likewise, undoing this change in the first element ofnestwill changesuitas well."
  },
  {
    "type": "code",
    "content": ">>> nest[0].pop(2)\n'Joker'\n>>> suits\n['heart', 'diamond', 'spade', 'club']\n"
  },
  {
    "type": "p",
    "content": "Stepping through this example line by line will show the representation of a\nnested list."
  },
  {
    "type": "p",
    "content": "Because two lists may have the same contents but in fact be different lists, we\nrequire a means to test whether two objects are the same.  Python includes two\ncomparison operators, calledisandis not, that test whether two\nexpressions in fact evaluate to the identical object.  Two objects are\nidentical if they are equal in their current value, and any change to one will\nalways be reflected in the other. Identity is a stronger condition than\nequality."
  },
  {
    "type": "code",
    "content": ">>> suits is nest[0]\nTrue\n>>> suits is ['heart', 'diamond', 'spade', 'club']\nFalse\n>>> suits == ['heart', 'diamond', 'spade', 'club']\nTrue\n"
  },
  {
    "type": "p",
    "content": "The final two comparisons illustrate the difference betweenisand==.\nThe former checks for identity, while the latter checks for the equality of\ncontents."
  },
  {
    "type": "p",
    "content": "List comprehensions.A list comprehension always creates a new list.\nFor example, theunicodedatamodule tracks the official names of every\ncharacter in the Unicode alphabet.  We can look up the characters corresponding\nto names, including those for card suits."
  },
  {
    "type": "code",
    "content": ">>> from unicodedata import lookup\n>>> [lookup('WHITE ' + s.upper() + ' SUIT') for s in suits]\n['♡', '♢', '♤', '♧']\n"
  },
  {
    "type": "p",
    "content": "This resulting list does not share any of its contents withsuits, and\nevaluating the list comprehension does not modify thesuitslist."
  },
  {
    "type": "p",
    "content": "You can read more about the Unicode standard for representing text in theUnicode sectionof Dive into Python 3."
  },
  {
    "type": "p",
    "content": "Tuples.A tuple, an instance of the built-intupletype, is an\nimmutable sequence. Tuples are created using a tuple literal that separates\nelement expressions by commas. Parentheses are optional but used commonly in\npractice. Any objects can be placed within tuples."
  },
  {
    "type": "code",
    "content": ">>> 1, 2 + 3\n(1, 5)\n>>> (\"the\", 1, (\"and\", \"only\"))\n('the', 1, ('and', 'only'))\n>>> type( (10, 20) )\n<class 'tuple'>\n"
  },
  {
    "type": "p",
    "content": "Empty and one-element tuples have special literal syntax."
  },
  {
    "type": "code",
    "content": ">>> ()    # 0 elements\n()\n>>> (10,) # 1 element\n(10,)\n"
  },
  {
    "type": "p",
    "content": "Like lists, tuples have a finite length and support element selection. They\nalso have a few methods that are also available for lists, such ascountandindex."
  },
  {
    "type": "code",
    "content": ">>> code = (\"up\", \"up\", \"down\", \"down\") + (\"left\", \"right\") * 2\n>>> len(code)\n8\n>>> code[3]\n'down'\n>>> code.count(\"down\")\n2\n>>> code.index(\"left\")\n4\n"
  },
  {
    "type": "p",
    "content": "However, the methods for manipulating the contents of a list are not available\nfor tuples because tuples are immutable."
  },
  {
    "type": "p",
    "content": "While it is not possible to change which elements are in a tuple, it is\npossible to change the value of a mutable element contained within a tuple."
  },
  {
    "type": "p",
    "content": "Tuples are used implicitly in multiple assignment. An assignment of two values\nto two names creates a two-element tuple and then unpacks it."
  },
  {
    "type": "h3",
    "content": "2.4.3   Dictionaries"
  },
  {
    "type": "p",
    "content": "Dictionaries are Python's built-in data type for storing and manipulating\ncorrespondence relationships.  A dictionary contains key-value pairs, where\nboth the keys and values are objects.  The purpose of a dictionary is to\nprovide an abstraction for storing and retrieving values that are indexed not\nby consecutive integers, but by descriptive keys."
  },
  {
    "type": "p",
    "content": "Strings commonly serve as keys, because strings are our conventional\nrepresentation for names of things. This dictionary literal gives the values of\nvarious Roman numerals."
  },
  {
    "type": "code",
    "content": ">>> numerals = {'I': 1.0, 'V': 5, 'X': 10}\n"
  },
  {
    "type": "p",
    "content": "Looking up values by their keys uses the element selection operator that we\npreviously applied to sequences."
  },
  {
    "type": "code",
    "content": ">>> numerals['X']\n10\n"
  },
  {
    "type": "p",
    "content": "A dictionary can have at most one value for each key.  Adding new key-value\npairs and changing the existing value for a key can both be achieved with\nassignment statements."
  },
  {
    "type": "code",
    "content": ">>> numerals['I'] = 1\n>>> numerals['L'] = 50\n>>> numerals\n{'I': 1, 'X': 10, 'L': 50, 'V': 5}\n"
  },
  {
    "type": "p",
    "content": "Notice that'L'was not added to the end of the output above.  Dictionaries\nare unordered collections of key-value pairs.  When we print a dictionary, the\nkeys and values are rendered in some order, but as users of the language we\ncannot predict what that order will be. The order may change when running a\nprogram multiple times."
  },
  {
    "type": "p",
    "content": "Dictionaries can appear in environment diagrams as well."
  },
  {
    "type": "p",
    "content": "The dictionary type also supports various methods of iterating over the\ncontents of the dictionary as a whole.  The methodskeys,values, anditemsall return iterable values."
  },
  {
    "type": "code",
    "content": ">>> sum(numerals.values())\n66\n"
  },
  {
    "type": "p",
    "content": "A list of key-value pairs can be converted into a dictionary by calling thedictconstructor function."
  },
  {
    "type": "code",
    "content": ">>> dict([(3, 9), (4, 16), (5, 25)])\n{3: 9, 4: 16, 5: 25}\n"
  },
  {
    "type": "p",
    "content": "Dictionaries do have some restrictions:"
  },
  {
    "type": "p",
    "content": "This first restriction is tied to the underlying implementation of dictionaries\nin Python. The details of this implementation are not a topic of this text.\nIntuitively, consider that the key tells Python where to find that key-value\npair in memory; if the key changes, the location of the pair may be lost.\nTuples are commonly used for keys in dictionaries because lists cannot be used."
  },
  {
    "type": "p",
    "content": "The second restriction is a consequence of the dictionary abstraction, which is\ndesigned to store and retrieve values for keys.  We can only retrievethevalue for a key if at most one such value exists in the dictionary."
  },
  {
    "type": "p",
    "content": "A useful method implemented by dictionaries isget, which returns either\nthe value for a key, if the key is present, or a default value.  The arguments\ntogetare the key and the default value."
  },
  {
    "type": "code",
    "content": ">>> numerals.get('A', 0)\n0\n>>> numerals.get('V', 0)\n5\n"
  },
  {
    "type": "p",
    "content": "Dictionaries also have a comprehension syntax analogous to those of lists.\nA key expression and a value expression are separated by a colon. Evaluating a\ndictionary comprehension creates a new dictionary object."
  },
  {
    "type": "code",
    "content": ">>> {x: x*x for x in range(3,6)}\n{3: 9, 4: 16, 5: 25}\n"
  },
  {
    "type": "h3",
    "content": "2.4.4   Local State"
  },
  {
    "type": "p",
    "content": "Lists and dictionaries havelocal state: they are changing values that have\nsome particular contents at any point in the execution of a program. The word\n\"state\" implies an evolving process in which that state may change."
  },
  {
    "type": "p",
    "content": "Functions can also have local state.  For instance, let us define a function\nthat models the process of withdrawing money from a bank account. We will\ncreate a function calledwithdraw, which takes as its argument an amount to\nbe withdrawn. If there is enough money in the account to accommodate the\nwithdrawal, thenwithdrawwill return the balance remaining after the\nwithdrawal. Otherwise,withdrawwill return the message'Insufficient\nfunds'.  For example, if we begin with $100 in the account, we would like to\nobtain the following sequence of return values by calling withdraw:"
  },
  {
    "type": "code",
    "content": ">>> withdraw(25)\n75\n>>> withdraw(25)\n50\n>>> withdraw(60)\n'Insufficient funds'\n>>> withdraw(15)\n35\n"
  },
  {
    "type": "p",
    "content": "Above, the expressionwithdraw(25), evaluated twice, yields different\nvalues. Thus, this user-defined function is non-pure. Calling the function not\nonly returns a value, but also has the side effect of changing the function in\nsome way, so that the next call with the same argument will return a different\nresult.  This side effect is a result ofwithdrawmaking a change to a\nname-value binding outside of the current frame."
  },
  {
    "type": "p",
    "content": "Forwithdrawto make sense, it must be created with an initial account\nbalance. The functionmake_withdrawis a higher-order function that takes a\nstarting balance as an argument.  The functionwithdrawis its return\nvalue."
  },
  {
    "type": "code",
    "content": ">>> withdraw = make_withdraw(100)\n"
  },
  {
    "type": "p",
    "content": "An implementation ofmake_withdrawrequires a new kind of statement: anonlocalstatement.  When we callmake_withdraw, we bind the namebalanceto the initial amount.  We then define and return a local function,withdraw, which updates and returns the value ofbalancewhen called."
  },
  {
    "type": "code",
    "content": ">>> def make_withdraw(balance):\n        \"\"\"Return a withdraw function that draws down balance with each call.\"\"\"\n        def withdraw(amount):\n            nonlocal balance                 # Declare the name \"balance\" nonlocal\n            if amount > balance:\n                return 'Insufficient funds'\n            balance = balance - amount       # Re-bind the existing balance name\n            return balance\n        return withdraw\n"
  },
  {
    "type": "p",
    "content": "Thenonlocalstatement declares that whenever we change the binding of the\nnamebalance, the binding is changed in the first frame in whichbalanceis already bound. Recall that without thenonlocalstatement,\nan assignment statement would always bind a name in the first frame of the\ncurrent environment.  Thenonlocalstatement indicates that the name\nappears somewhere in the environment other than the first (local) frame or the\nlast (global) frame."
  },
  {
    "type": "p",
    "content": "The following environment diagrams illustrate the effects of multiple calls to\na function created bymake_withdraw."
  },
  {
    "type": "p",
    "content": "The first def statement has the usual effect: it creates a new user-defined\nfunction and binds the namemake_withdrawto that function in the global\nframe. The subsequent call tomake_withdrawcreates and returns a locally\ndefined functionwithdraw.  The namebalanceis bound in the parent\nframe of this function.  Crucially, there will only be this single binding for\nthe namebalancethroughout the rest of this example."
  },
  {
    "type": "p",
    "content": "Next, we evaluate an expression that calls this function, bound to the namewd, on an amount 5.  The body ofwithdrawis executed in a new\nenvironment that extends the environment in whichwithdrawwas defined.\nTracing the effect of evaluatingwithdrawillustrates the effect of anonlocalstatement in Python: a name outside of the first local frame can\nbe changed by an assignment statement."
  },
  {
    "type": "p",
    "content": "Thenonlocalstatement changes all of the remaining assignment statements\nin the definition ofwithdraw.  After executingnonlocal balance, any\nassignment statement withbalanceon the left-hand side of=will not\nbindbalancein the first frame of the current environment.  Instead, it\nwill find the first frame in whichbalancewas already defined and re-bind\nthe name in that frame.  Ifbalancehas not previously been bound to a\nvalue, then thenonlocalstatement will give an error."
  },
  {
    "type": "p",
    "content": "By virtue of changing the binding forbalance, we have changed thewithdrawfunction as well.  The next time it is called, the namebalancewill evaluate to 15 instead of 20.  Hence, when we callwithdrawa second time, we see that its return value is 12 and not\n17.  The change tobalancefrom the first call affects the result of\nthe second call."
  },
  {
    "type": "p",
    "content": "The second call towithdrawdoes create a second local frame, as usual.\nHowever, bothwithdrawframes have the same parent.  That is, they both\nextend the environment formake_withdraw, which contains the binding forbalance.  Hence, they share that particular name binding.  Callingwithdrawhas the side effect of altering the environment that will be\nextended by future calls towithdraw.  Thenonlocalstatement allowswithdrawto change a name binding in themake_withdrawframe."
  },
  {
    "type": "p",
    "content": "Ever since we first encountered nesteddefstatements, we have observed\nthat a locally defined function can look up names outside of its local frames.\nNononlocalstatement is required toaccessa non-local name.  By\ncontrast, only after anonlocalstatement can a functionchangethe\nbinding of names in these frames."
  },
  {
    "type": "p",
    "content": "By introducingnonlocalstatements, we have created a dual role for\nassignment statements.  Either they change local bindings, or they change\nnonlocal bindings.  In fact, assignment statements already had a dual role:\nthey either created new bindings or re-bound existing names. Assignment can\nalso change the contents of lists and dictionaries. The many roles of Python\nassignment can obscure the effects of executing an assignment statement. It is\nup to you as a programmer to document your code clearly so that the effects of\nassignment can be understood by others."
  },
  {
    "type": "p",
    "content": "Python Particulars.This pattern of non-local assignment is a general\nfeature of programming languages with higher-order functions and lexical scope.\nMost other languages do not require anonlocalstatement at all. Instead,\nnon-local assignment is often the default behavior of assignment statements."
  },
  {
    "type": "p",
    "content": "Python also has an unusual restriction regarding the lookup of names: within\nthe body of a function, all instances of a name must refer to the same frame.\nAs a result, Python cannot look up the value of a name in a non-local frame,\nthen bind that same name in the local frame, because the same name would be\naccessed in two different frames in the same function.  This restriction\nallows Python to pre-compute which frame contains each name before executing\nthe body of a function. When this restriction is violated, a confusing error\nmessage results.  To demonstrate, themake_withdrawexample is repeated\nbelow with thenonlocalstatement removed."
  },
  {
    "type": "p",
    "content": "ThisUnboundLocalErrorappears becausebalanceis assigned locally in\nline 5, and so Python assumes that all references tobalancemust\nappear in the local frame as well.  This error occursbeforeline 5 is\never executed, implying that Python has considered line 5 in some way\nbefore executing line 3. As we study interpreter design, we will see that\npre-computing facts about a function body before executing it is quite common.\nIn this case, Python's pre-processing restricted the frame in whichbalancecould appear, and thus prevented the name from being found. Adding anonlocalstatement corrects this error. Thenonlocalstatement did not\nexist in Python 2."
  },
  {
    "type": "h3",
    "content": "2.4.5   The Benefits of Non-Local Assignment"
  },
  {
    "type": "p",
    "content": "Non-local assignment is an important step on our path to viewing a program as a\ncollection of independent and autonomousobjects, which interact with each\nother but each manage their own internal state."
  },
  {
    "type": "p",
    "content": "In particular, non-local assignment has given us the ability to maintain some\nstate that is local to a function, but evolves over successive calls to that\nfunction.  Thebalanceassociated with a particular withdraw function is\nshared among all calls to that function. However, the binding for balance\nassociated with an instance of withdraw is inaccessible to the rest of the\nprogram.  Onlywdis associated with the frame formake_withdrawin\nwhich it was defined.  Ifmake_withdrawis called again, then it will\ncreate a separate frame with a separate binding forbalance."
  },
  {
    "type": "p",
    "content": "We can extend our example to illustrate this point.  A second call tomake_withdrawreturns a secondwithdrawfunction that has a different\nparent. We bind this second function to the namewd2in the global frame."
  },
  {
    "type": "p",
    "content": "Now, we see that there are in fact two bindings for the namebalancein two\ndifferent frames, and eachwithdrawfunction has a different parent. The\nnamewdis bound to a function with a balance of 20, whilewd2is bound to a different function with a balance of 7."
  },
  {
    "type": "p",
    "content": "Callingwd2changes the binding of its non-localbalancename, but\ndoes not affect the function bound to the namewithdraw. A future call towdis unaffected by the changing balance ofwd2; its balance is still\n20."
  },
  {
    "type": "p",
    "content": "In this way, each instance ofwithdrawmaintains its own balance state,\nbut that state is inaccessible to any other function in the program.  Viewing\nthis situation at a higher level, we have created an abstraction of a bank\naccount that manages its own internals but behaves in a way that models accounts\nin the world: it changes over time based on its own history of withdrawal\nrequests."
  },
  {
    "type": "h3",
    "content": "2.4.6   The Cost of Non-Local Assignment"
  },
  {
    "type": "p",
    "content": "Our environment model of computation cleanly extends to explain the effects of\nnon-local assignment.  However, non-local assignment introduces some important\nnuances in the way we think about names and values."
  },
  {
    "type": "p",
    "content": "Previously, our values did not change; only our names and bindings changed.\nWhen two namesaandbwere both bound to the value 4, it did not\nmatter whether they were bound to the same 4 or different 4's.  As far\nas we could tell, there was only one 4 object that never changed."
  },
  {
    "type": "p",
    "content": "However, functions with state do not behave this way.  When two nameswdandwd2are both bound to awithdrawfunction, itdoesmatter whether\nthey are bound to the same function or different instances of that function.\nConsider the following example, which contrasts the one we just analyzed.\nIn this case, calling the function named bywd2did change the value of the\nfunction named bywd, because both names refer to the same function."
  },
  {
    "type": "p",
    "content": "It is not unusual for two names to co-refer to the same value in the world, and\nso it is in our programs.  But, as values change over time, we must be very\ncareful to understand the effect of a change on other names that might refer to\nthose values."
  },
  {
    "type": "p",
    "content": "The key to correctly analyzing code with non-local assignment is to remember\nthat only function calls can introduce new frames.  Assignment statements always\nchange bindings in existing frames.  In this case, unlessmake_withdrawis\ncalled twice, there can be only one binding forbalance."
  },
  {
    "type": "p",
    "content": "Sameness and change.These subtleties arise because, by introducing non-pure\nfunctions that change the non-local environment, we have changed the nature of\nexpressions.  An expression that contains only pure function calls isreferentially transparent; its value does not change if we substitute one of\nits subexpression with the value of that subexpression."
  },
  {
    "type": "p",
    "content": "Re-binding operations violate the conditions of referential transparency because\nthey do more than return a value; they change the environment.  When we\nintroduce arbitrary re-binding, we encounter a thorny epistemological issue:\nwhat it means for two values to be the same. In our environment model of\ncomputation, two separately defined functions are not the same, because changes\nto one may not be reflected in the other."
  },
  {
    "type": "p",
    "content": "In general, so long as we never modify data objects, we can regard a compound\ndata object to be precisely the totality of its pieces. For example, a rational\nnumber is determined by giving its numerator and its denominator. But this view\nis no longer valid in the presence of change, where a compound data object has\nan \"identity\" that is something different from the pieces of which it is\ncomposed. A bank account is still \"the same\" bank account even if we change the\nbalance by making a withdrawal; conversely, we could have two bank accounts that\nhappen to have the same balance, but are different objects."
  },
  {
    "type": "p",
    "content": "Despite the complications it introduces, non-local assignment is a powerful tool\nfor creating modular programs. Different parts of a program, which correspond to\ndifferent environment frames, can evolve separately throughout program\nexecution.  Moreover, using functions with local state, we are able to implement\nmutable data types.  In fact, we can implement abstract data types that are\nequivalent to the built-inlistanddicttypes introduced above."
  },
  {
    "type": "h3",
    "content": "2.4.7   Implementing Lists and Dictionaries"
  },
  {
    "type": "p",
    "content": "The Python language does not give us access to the implementation of lists,\nonly to the sequence abstraction and mutation methods built into the language.\nTo understand how a mutable list could be represented using functions with\nlocal state, we will now develop an implementation of a mutable linked list."
  },
  {
    "type": "p",
    "content": "We will represent a mutable linked list by a function that has a linked list as\nits local state.  Lists need to have an identity, like any mutable value.  In\nparticular, we cannot useNoneto represent an empty mutable list, because\ntwo empty lists are not identical values (e.g., appending to one does not\nappend to the other), butNone is None.  On the other hand, two different\nfunctions that each haveemptyas their local state will suffice to\ndistinguish two empty lists."
  },
  {
    "type": "p",
    "content": "If a mutable linked list is a function, what arguments does it take? The answer\nexhibits a general pattern in programming: the function is a dispatch function\nand its arguments are first a message, followed by additional arguments to\nparameterize that method. This message is a string naming what the function\nshould do. Dispatch functions are effectively many functions in one: the\nmessage determines the behavior of the function, and the additional arguments\nare used in that behavior."
  },
  {
    "type": "p",
    "content": "Our mutable list will respond to five different messages:len,getitem,push_first,pop_first, andstr.  The first two implement the\nbehaviors of the sequence abstraction.  The next two add or remove the first\nelement of the list.  The final message returns a string representation of the\nwhole linked list."
  },
  {
    "type": "code",
    "content": ">>> def mutable_link():\n        \"\"\"Return a functional implementation of a mutable linked list.\"\"\"\n        contents = empty\n        def dispatch(message, value=None):\n            nonlocal contents\n            if message == 'len':\n                return len_link(contents)\n            elif message == 'getitem':\n                return getitem_link(contents, value)\n            elif message == 'push_first':\n                contents = link(value, contents)\n            elif message == 'pop_first':\n                f = first(contents)\n                contents = rest(contents)\n                return f\n            elif message == 'str':\n                return join_link(contents, \", \")\n        return dispatch\n"
  },
  {
    "type": "p",
    "content": "We can also add a convenience function to construct a functionally implemented\nlinked list from any built-in sequence, simply by adding each element in\nreverse order."
  },
  {
    "type": "code",
    "content": ">>> def to_mutable_link(source):\n        \"\"\"Return a functional list with the same contents as source.\"\"\"\n        s = mutable_link()\n        for element in reversed(source):\n            s('push_first', element)\n        return s\n"
  },
  {
    "type": "p",
    "content": "In the definition above, the functionreversedtakes and returns an\niterable value; it is another example of a function that processes sequences."
  },
  {
    "type": "p",
    "content": "At this point, we can construct a functionally implemented mutable linked\nlists.  Note that the linked list itself is a function."
  },
  {
    "type": "code",
    "content": ">>> s = to_mutable_link(suits)\n>>> type(s)\n<class 'function'>\n>>> print(s('str'))\nheart, diamond, spade, club\n"
  },
  {
    "type": "p",
    "content": "In addition, we can pass messages to the liststhat change its contents,\nfor instance removing the first element."
  },
  {
    "type": "code",
    "content": ">>> s('pop_first')\n'heart'\n>>> print(s('str'))\ndiamond, spade, club\n"
  },
  {
    "type": "p",
    "content": "In principle, the operationspush_firstandpop_firstsuffice to make\narbitrary changes to a list.  We can always empty out the list entirely and then\nreplace its old contents with the desired result."
  },
  {
    "type": "p",
    "content": "Message passing.Given some time, we could implement the many useful\nmutation operations of Python lists, such asextendandinsert.  We\nwould have a choice: we could implement them all as functions, which use the\nexisting messagespop_firstandpush_firstto make all changes.\nAlternatively, we could add additionalelifclauses to the body ofdispatch, each checking for a message (e.g.,'extend') and applying the\nappropriate change tocontentsdirectly."
  },
  {
    "type": "p",
    "content": "This second approach, which encapsulates the logic for all operations on a data\nvalue within one function that responds to different messages, is a discipline\ncalled message passing.  A program that uses message passing defines dispatch\nfunctions, each of which may have local state, and organizes computation by\npassing \"messages\" as the first argument to those functions.  The messages are\nstrings that correspond to particular behaviors."
  },
  {
    "type": "p",
    "content": "Implementing Dictionaries.We can also implement a value with similar\nbehavior to a dictionary. In this case, we use a list of key-value pairs to\nstore the contents of the dictionary. Each pair is a two-element list."
  },
  {
    "type": "code",
    "content": ">>> def dictionary():\n        \"\"\"Return a functional implementation of a dictionary.\"\"\"\n        records = []\n        def getitem(key):\n            matches = [r for r in records if r[0] == key]\n            if len(matches) == 1:\n                key, value = matches[0]\n                return value\n        def setitem(key, value):\n            nonlocal records\n            non_matches = [r for r in records if r[0] != key]\n            records = non_matches + [[key, value]]\n        def dispatch(message, key=None, value=None):\n            if message == 'getitem':\n                return getitem(key)\n            elif message == 'setitem':\n                setitem(key, value)\n        return dispatch\n"
  },
  {
    "type": "p",
    "content": "Again, we use the message passing method to organize our implementation.  We\nhave supported two messages:getitemandsetitem.   To insert a value\nfor a key, we filter out any existing records with the given key, then add one.\nIn this way, we are assured that each key appears only once in records. To look\nup a value for a key, we filter for the record that matches the given key.   We\ncan now use our implementation to store and retrieve values."
  },
  {
    "type": "code",
    "content": ">>> d = dictionary()\n>>> d('setitem', 3, 9)\n>>> d('setitem', 4, 16)\n>>> d('getitem', 3)\n9\n>>> d('getitem', 4)\n16\n"
  },
  {
    "type": "p",
    "content": "This implementation of a dictionary isnotoptimized for fast record lookup,\nbecause each call must filter through all records. The built-in dictionary type\nis considerably more efficient. The way in which it is implemented is beyond\nthe scope of this text."
  },
  {
    "type": "h3",
    "content": "2.4.8   Dispatch Dictionaries"
  },
  {
    "type": "p",
    "content": "The dispatch function is a general method for implementing a message passing\ninterface for abstract data. To implement message dispatch, we have thus far\nused conditional statements to compare the message string to a fixed set of\nknown messages."
  },
  {
    "type": "p",
    "content": "The built-in dictionary data type provides a general method for looking up a\nvalue for a key. Instead of using conditionals to implement dispatching, we can\nuse dictionaries with string keys."
  },
  {
    "type": "p",
    "content": "The mutableaccountdata type below is implemented as a dictionary.  It\nhas a constructoraccountand selectorcheck_balance, as well as\nfunctions todepositorwithdrawfunds. Moreover, the local state of\nthe account is stored in the dictionary alongside the functions that implement\nits behavior."
  },
  {
    "type": "p",
    "content": "The namedispatchwithin the body of theaccountconstructor is bound\nto a dictionary that contains the messages accepted by an account as keys. Thebalanceis a number, while the messagesdepositandwithdraware bound to\nfunctions. These functions have access to thedispatchdictionary, and so\nthey can read and change the balance. By storing the balance in the dispatch\ndictionary rather than in theaccountframe directly, we avoid the need fornonlocalstatements indepositandwithdraw."
  },
  {
    "type": "p",
    "content": "The operators+=and-=are shorthand in Python (and many other\nlanguages) for combined lookup and re-assignment.  The last two lines below are\nequivalent."
  },
  {
    "type": "code",
    "content": ">>> a = 2\n>>> a = a + 1\n>>> a += 1\n"
  },
  {
    "type": "h3",
    "content": "2.4.9   Propagating Constraints"
  },
  {
    "type": "p",
    "content": "Mutable data allows us to simulate systems with change, but also allows us to\nbuild new kinds of abstractions.  In this extended example, we combine nonlocal\nassignment, lists, and dictionaries to build aconstraint-based systemthat\nsupports computation in multiple directions. Expressing programs as constraints\nis a type ofdeclarative programming, in which a programmer declares the\nstructure of a problem to be solved, but abstracts away the details of exactly\nhow the solution to the problem is computed."
  },
  {
    "type": "p",
    "content": "Computer programs are traditionally organized as one-directional computations,\nwhich perform operations on pre-specified arguments to produce desired outputs.\nOn the other hand, we often want to model systems in terms of relations among\nquantities. For example, we previously considered the ideal gas law, which\nrelates the pressure (p), volume (v), quantity (n), and temperature\n(t) of an ideal gas via Boltzmann's constant (k):"
  },
  {
    "type": "p",
    "content": "Such an equation is not one-directional. Given any four of the quantities, we\ncan use this equation to compute the fifth. Yet translating the equation into a\ntraditional computer language would force us to choose one of the quantities to\nbe computed in terms of the other four. Thus, a function for computing the\npressure could not be used to compute the temperature, even though the\ncomputations of both quantities arise from the same equation."
  },
  {
    "type": "p",
    "content": "In this section, we sketch the design of a general model of linear\nrelationships.  We define primitive constraints that hold between quantities,\nsuch as anadder(a, b, c)constraint that enforces the mathematical\nrelationshipa + b = c."
  },
  {
    "type": "p",
    "content": "We also define a means of combination, so that primitive constraints can be\ncombined to express more complex relations.  In this way, our program resembles\na programming language.  We combine constraints by constructing a network in\nwhich constraints are joined by connectors. A connector is an object that\n\"holds\" a value and may participate in one or more constraints."
  },
  {
    "type": "p",
    "content": "For example, we know that the relationship between Fahrenheit and Celsius\ntemperatures is:"
  },
  {
    "type": "p",
    "content": "This equation is a complex constraint betweencandf. Such a constraint\ncan be thought of as a network consisting of primitiveadder,multiplier, andconstantconstraints."
  },
  {
    "type": "p",
    "content": "In this figure, we see on the left a multiplier box with three terminals,\nlabeleda,b, andc. These connect the multiplier to the rest of the\nnetwork as follows: Theaterminal is linked to a connectorcelsius,\nwhich will hold the Celsius temperature. Thebterminal is linked to a\nconnectorw, which is also linked to a constant box that holds 9. Thecterminal, which the multiplier box constrains to be the product ofaandb, is linked to thecterminal of another multiplier box, whosebis connected to a constant 5 and whoseais connected to one of the terms\nin the sum constraint."
  },
  {
    "type": "p",
    "content": "Computation by such a network proceeds as follows: When a connector is given a\nvalue (by the user or by a constraint box to which it is linked), it awakens all\nof its associated constraints (except for the constraint that just awakened it)\nto inform them that it has a value. Each awakened constraint box then polls its\nconnectors to see if there is enough information to determine a value for a\nconnector. If so, the box sets that connector, which then awakens all of its\nassociated constraints, and so on. For instance, in conversion between Celsius\nand Fahrenheit,w,x, andyare immediately set by the constant\nboxes to 9, 5, and 32, respectively. The connectors awaken the\nmultipliers and the adder, which determine that there is not enough information\nto proceed. If the user (or some other part of the network) sets thecelsiusconnector to a value (say 25), the leftmost multiplier will be awakened, and\nit will setuto25 * 9 = 225.  Thenuawakens the second\nmultiplier, which setsvto 45, andvawakens the adder, which sets\nthefahrenheitconnector to 77."
  },
  {
    "type": "p",
    "content": "Using the Constraint System.To use the constraint system to carry out the\ntemperature computation outlined above, we first create two named connectors,celsiusandfahrenheit, by calling theconnectorconstructor."
  },
  {
    "type": "code",
    "content": ">>> celsius = connector('Celsius')\n>>> fahrenheit = connector('Fahrenheit')\n"
  },
  {
    "type": "p",
    "content": "Then, we link these connectors into a network that mirrors the figure above.\nThe functionconverterassembles the various connectors and constraints\nin the network."
  },
  {
    "type": "code",
    "content": ">>> def converter(c, f):\n        \"\"\"Connect c to f with constraints to convert from Celsius to Fahrenheit.\"\"\"\n        u, v, w, x, y = [connector() for _ in range(5)]\n        multiplier(c, w, u)\n        multiplier(v, x, u)\n        adder(v, y, f)\n        constant(w, 9)\n        constant(x, 5)\n        constant(y, 32)\n"
  },
  {
    "type": "code",
    "content": ">>> converter(celsius, fahrenheit)\n"
  },
  {
    "type": "p",
    "content": "We will use a message passing system to coordinate constraints and connectors.\nConstraints are dictionaries that do not hold local states themselves. Their\nresponses to messages are non-pure functions that change the connectors that\nthey constrain."
  },
  {
    "type": "p",
    "content": "Connectors are dictionaries that hold a current value and respond to messages\nthat manipulate that value.  Constraints will not change the value of connectors\ndirectly, but instead will do so by sending messages, so that the connector can\nnotify other constraints in response to the change.  In this way, a connector\nrepresents a number, but also encapsulates connector behavior."
  },
  {
    "type": "p",
    "content": "One message we can send to a connector is to set its value.  Here, we (the'user') set the value ofcelsiusto 25."
  },
  {
    "type": "code",
    "content": ">>> celsius['set_val']('user', 25)\nCelsius = 25\nFahrenheit = 77.0\n"
  },
  {
    "type": "p",
    "content": "Not only does the value ofcelsiuschange to 25, but its value\npropagates through the network, and so the value offahrenheitis changed as\nwell.  These changes are printed because we named these two connectors when we\nconstructed them."
  },
  {
    "type": "p",
    "content": "Now we can try to setfahrenheitto a new value, say 212."
  },
  {
    "type": "code",
    "content": ">>> fahrenheit['set_val']('user', 212)\nContradiction detected: 77.0 vs 212\n"
  },
  {
    "type": "p",
    "content": "The connector complains that it has sensed a contradiction: Its value is\n77.0, and someone is trying to set it to 212. If we really want to reuse\nthe network with new values, we can tellcelsiusto forget its old value:"
  },
  {
    "type": "code",
    "content": ">>> celsius['forget']('user')\nCelsius is forgotten\nFahrenheit is forgotten\n"
  },
  {
    "type": "p",
    "content": "The connectorcelsiusfinds that theuser, who set its value originally,\nis now retracting that value, socelsiusagrees to lose its value, and it\ninforms the rest of the network of this fact. This information eventually\npropagates tofahrenheit, which now finds that it has no reason for\ncontinuing to believe that its own value is 77. Thus, it also gives up its\nvalue."
  },
  {
    "type": "p",
    "content": "Now thatfahrenheithas no value, we are free to set it to 212:"
  },
  {
    "type": "code",
    "content": ">>> fahrenheit['set_val']('user', 212)\nFahrenheit = 212\nCelsius = 100.0\n"
  },
  {
    "type": "p",
    "content": "This new value, when propagated through the network, forcescelsiusto have\na value of 100. We have used the very same network to computecelsiusgivenfahrenheitand to computefahrenheitgivencelsius. This\nnon-directionality of computation is the distinguishing feature of\nconstraint-based systems."
  },
  {
    "type": "p",
    "content": "Implementing the Constraint System.As we have seen, connectors are\ndictionaries that map message names to function and data values.  We will\nimplement connectors that respond to the following messages:"
  },
  {
    "type": "p",
    "content": "Constraints are also dictionaries, which receive information from connectors by\nmeans of two messages:"
  },
  {
    "type": "p",
    "content": "When constraints receive these messages, they propagate them appropriately to\nother connectors."
  },
  {
    "type": "p",
    "content": "Theadderfunction constructs an adder constraint over three connectors,\nwhere the first two must add to the third:a + b = c.  To support\nmultidirectional constraint propagation, the adder must also specify that it\nsubtractsafromcto getband likewise subtractsbfromcto geta."
  },
  {
    "type": "code",
    "content": ">>> from operator import add, sub\n>>> def adder(a, b, c):\n        \"\"\"The constraint that a + b = c.\"\"\"\n        return make_ternary_constraint(a, b, c, add, sub, sub)\n"
  },
  {
    "type": "p",
    "content": "We would like to implement a generic ternary (three-way) constraint, which\nuses the three connectors and three functions fromadderto create a\nconstraint that acceptsnew_valandforgetmessages.  The response to\nmessages are local functions, which are placed in a dictionary calledconstraint."
  },
  {
    "type": "code",
    "content": ">>> def make_ternary_constraint(a, b, c, ab, ca, cb):\n        \"\"\"The constraint that ab(a,b)=c and ca(c,a)=b and cb(c,b) = a.\"\"\"\n        def new_value():\n            av, bv, cv = [connector['has_val']() for connector in (a, b, c)]\n            if av and bv:\n                c['set_val'](constraint, ab(a['val'], b['val']))\n            elif av and cv:\n                b['set_val'](constraint, ca(c['val'], a['val']))\n            elif bv and cv:\n                a['set_val'](constraint, cb(c['val'], b['val']))\n        def forget_value():\n            for connector in (a, b, c):\n                connector['forget'](constraint)\n        constraint = {'new_val': new_value, 'forget': forget_value}\n        for connector in (a, b, c):\n            connector['connect'](constraint)\n        return constraint\n"
  },
  {
    "type": "p",
    "content": "The dictionary calledconstraintis a dispatch dictionary, but also the\nconstraint object itself. It responds to the two messages that constraints\nreceive, but is also passed as thesourceargument in calls to its\nconnectors."
  },
  {
    "type": "p",
    "content": "The constraint's local functionnew_valueis called whenever the constraint\nis informed that one of its connectors has a value. This function first checks\nto see if bothaandbhave values. If so, it tellscto set its\nvalue to the return value of functionab, which isaddin the case of anadder. The constraint passesitself(constraint) as thesourceargument of the connector, which is the adder object. Ifaandbdo not\nboth have values, then the constraint checksaandc, and so on."
  },
  {
    "type": "p",
    "content": "If the constraint is informed that one of its connectors has forgotten its\nvalue, it requests that all of its connectors now forget their values. (Only\nthose values that were set by this constraint are actually lost.)"
  },
  {
    "type": "p",
    "content": "Amultiplieris very similar to anadder."
  },
  {
    "type": "code",
    "content": ">>> from operator import mul, truediv\n>>> def multiplier(a, b, c):\n        \"\"\"The constraint that a * b = c.\"\"\"\n        return make_ternary_constraint(a, b, c, mul, truediv, truediv)\n"
  },
  {
    "type": "p",
    "content": "A constant is a constraint as well, but one that is never sent any messages,\nbecause it involves only a single connector that it sets on construction."
  },
  {
    "type": "code",
    "content": ">>> def constant(connector, value):\n        \"\"\"The constraint that connector = value.\"\"\"\n        constraint = {}\n        connector['set_val'](constraint, value)\n        return constraint\n"
  },
  {
    "type": "p",
    "content": "These three constraints are sufficient to implement our temperature conversion\nnetwork."
  },
  {
    "type": "p",
    "content": "Representing connectors.A connector is represented as a dictionary that\ncontains a value, but also has response functions with local state.  The\nconnector must track theinformantthat gave it its current value, and a\nlist ofconstraintsin which it participates."
  },
  {
    "type": "p",
    "content": "The constructorconnectorhas local functions for setting and\nforgetting values, which are the responses to messages from constraints."
  },
  {
    "type": "code",
    "content": ">>> def connector(name=None):\n        \"\"\"A connector between constraints.\"\"\"\n        informant = None\n        constraints = []\n        def set_value(source, value):\n            nonlocal informant\n            val = connector['val']\n            if val is None:\n                informant, connector['val'] = source, value\n                if name is not None:\n                    print(name, '=', value)\n                inform_all_except(source, 'new_val', constraints)\n            else:\n                if val != value:\n                    print('Contradiction detected:', val, 'vs', value)\n        def forget_value(source):\n            nonlocal informant\n            if informant == source:\n                informant, connector['val'] = None, None\n                if name is not None:\n                    print(name, 'is forgotten')\n                inform_all_except(source, 'forget', constraints)\n        connector = {'val': None,\n                     'set_val': set_value,\n                     'forget': forget_value,\n                     'has_val': lambda: connector['val'] is not None,\n                     'connect': lambda source: constraints.append(source)}\n        return connector\n"
  },
  {
    "type": "p",
    "content": "A connector is again a dispatch dictionary for the five messages used by\nconstraints to communicate with connectors. Four responses are functions, and\nthe final response is the value itself."
  },
  {
    "type": "p",
    "content": "The local functionset_valueis called when there is a request to set the\nconnector's value. If the connector does not currently have a value, it will set\nits value and remember asinformantthe source constraint that requested the\nvalue to be set. Then the connector will notify all of its participating\nconstraints except the constraint that requested the value to be set. This is\naccomplished using the following iterative function."
  },
  {
    "type": "code",
    "content": ">>> def inform_all_except(source, message, constraints):\n        \"\"\"Inform all constraints of the message, except source.\"\"\"\n        for c in constraints:\n            if c != source:\n                c[message]()\n"
  },
  {
    "type": "p",
    "content": "If a connector is asked to forget its value, it calls the local functionforget-value, which first checks to make sure that the request is coming\nfrom the same constraint that set the value originally. If so, the connector\ninforms its associated constraints about the loss of the value."
  },
  {
    "type": "p",
    "content": "The response to the messagehas_valindicates whether the connector has a\nvalue.  The response to the messageconnectadds the source constraint to\nthe list of constraints."
  },
  {
    "type": "p",
    "content": "The constraint program we have designed introduces many ideas that will appear\nagain in object-oriented programming.  Constraints and connectors are both\nabstractions that are manipulated through messages.  When the value of a\nconnector is changed, it is changed via a message that not only changes the\nvalue, but validates it (checking the source) and propagates its effects\n(informing other constraints).  In fact, we will use a similar architecture of\ndictionaries with string-valued keys and functional values to implement an\nobject-oriented system later in this chapter."
  },
  {
    "type": "p",
    "content": "Continue:2.5 Object-Oriented Programming"
  }
]